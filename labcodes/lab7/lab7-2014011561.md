# Lab 7 实验报告

#### 2014011561 张欣阳

> 注：为了在mac下编译，修改了Makefile文件，如果不能编译，请使用Makefile.bk

--------------------------------------------------------------------------------

## 练习0：更新以往lab
在lab7中，引入了计时器，在时钟中断产生时，调用`run_timer_list`从计时器队列里选择进程执行。在计时器机制下，替代了上个lab中直接在`trap_dispatch`中调用`sched_class_proc_tick`的实现。我们可以看到`run_timer_list`的实现如下：

```c
// call scheduler to update tick related info, and check the timer is expired? If expired, then wakup proc
void
run_timer_list(void) {
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        list_entry_t *le = list_next(&timer_list);
        if (le != &timer_list) {
            timer_t *timer = le2timer(le, timer_link);
            assert(timer->expires != 0);
            timer->expires --;
            while (timer->expires == 0) {
                le = list_next(le);
                struct proc_struct *proc = timer->proc;
                if (proc->wait_state != 0) {
                    assert(proc->wait_state & WT_INTERRUPTED);
                }
                else {
                    warn("process %d's wait_state == 0.\n", proc->pid);
                }
                wakeup_proc(proc);
                del_timer(timer);
                if (le == &timer_list) {
                    break;
                }
                timer = le2timer(le, timer_link);
            }
        }
        sched_class_proc_tick(current);
    }
    local_intr_restore(intr_flag);
}
```
在这里面调用了`sched_class_proc_tick`来执行调度。

基于此，更改`trap_dispatch`中相关部分如下：
```c
case IRQ_OFFSET + IRQ_TIMER:
    ticks++;
    assert(current != NULL);
    run_timer_list();
    break;
```

## 练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
### 内核级信号量设计
ucore在sem.h中，定义了信号量的数据结构和函数：
```c
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;

void sem_init(semaphore_t *sem, int value);
void up(semaphore_t *sem);
void down(semaphore_t *sem);
bool try_down(semaphore_t *sem);
```
信号量的结构体定义与其原理是对应的，包括资源量和一个进程等待队列。

`sem_init()`函数实现如下：
```c
void
sem_init(semaphore_t *sem, int value) {
    sem->value = value;
    wait_queue_init(&(sem->wait_queue));
}
```
实现非常简单，主要用来初始化信号量结构体，包括等待队列，以及资源的初始值；

`down`对应P操作，具体实现在`__down`函数中，其代码如下：
```c
static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    if (sem->value > 0) {
        sem->value --;
        local_intr_restore(intr_flag);
        return 0;
    }
    wait_t __wait, *wait = &__wait;
    wait_current_set(&(sem->wait_queue), wait, wait_state);
    local_intr_restore(intr_flag);

    schedule();

    local_intr_save(intr_flag);
    wait_current_del(&(sem->wait_queue), wait);
    local_intr_restore(intr_flag);

    if (wait->wakeup_flags != wait_state) {
        return wait->wakeup_flags;
    }
    return 0;
}

```
值得注意的是，该函数是通过关中断的方式来实现互斥访问的，过程与其原理完全对应：首先关掉中断，然后判断当前信号量的value是否大于0。如果是>0，则表明可以获得信号量，故让value减一，并打开中断返回即可；如果不是>0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除（此过程需要先关中断，完成后开中断）。
·
`up`对应V操作，具体是现在`__up`函数中，其代码如下：
```c
static __noinline void __up(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        wait_t *wait;
        if ((wait = wait_queue_first(&(sem->wait_queue))) == NULL) {
            sem->value ++;
        }
        else {
            assert(wait->proc->wait_state == wait_state);
            wakeup_wait(&(sem->wait_queue), wait, wait_state, 1);
        }
    }
    local_intr_restore(intr_flag);
}
```
这个实现也与原理完全对应，首先关中断，如果信号量对应的wait queue中没有进程在等待，直接把信号量的value加一，然后开中断返回；如果有进程在等待且进程等待的原因是semophore设置的，则调用wakeup_wait函数将waitqueue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后开中断返回。

这里还有一个函数`try_down`，它并没有被调用过，从实现上看好像是一个不包括等待队列的，不完全的`down`函数实现，可能用于调试。

值得注意的是，上一个lab中`mm_struct`中的`lock_t`也被`semaphore_t`代替了，通过信号量来表示进程的互斥锁。

ucore中，直接在`check_sync`函数中调用哲学家就餐代码，检查同步互斥实现，所以这部分代码在内核态运行。直接调用上面的信号量结构和函数就可以使用信号量了。

### 用户态信号量机制的设计方案
用户进程中，不能直接调用上面实现的信号量代码，因为这部分代码需要内核态的权限运行，但是我们仍然可以尝试复用这些代码。例如，我们可以编写用户态的库函数，复用`semaphore_t`结构体，但在调用`sem_init`，`up`和`down`时，通过系统调用的方式，增加三种系统调用；再在系统调用的实现中调用内核态的信号量代码，从而实现用户态的信号量机制。

## 练习2：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
··
